import os
import json
import requests
import hashlib
import fitz  # PyMuPDF
from datetime import datetime
from flask import Flask, request, render_template, jsonify, redirect, session
from dotenv import load_dotenv

load_dotenv()
app = Flask(__name__)
app.secret_key = os.getenv("SECRET_KEY", "your-secret-key-change-this")

# Load config
with open("config.json", "r") as f:
    config = json.load(f)

# Check for required environment variables
openai_api_key = os.getenv("OPENAI_API_KEY")
claude_api_key = os.getenv("CLAUDE_API_KEY")
admin_password = os.getenv("ADMIN_PASSWORD", "admin123")

if not openai_api_key:
    print("WARNING: OPENAI_API_KEY not found in environment variables")
if not claude_api_key:
    print("WARNING: CLAUDE_API_KEY not found in environment variables")

# Globals
user_sessions = {}  # Store per-user chat history and personal documents

# File paths
LOG_FILE = "logs/chat_history.json"
KNOWLEDGE_BASE_FILE = "core_memory/knowledge_base.json"  # ADMIN ONLY - Global therapeutic knowledge
CORE_MEMORY_DIR = "core_memory"
UPLOADS_DIR = "uploads"  # ADMIN uploads
USER_UPLOADS_DIR = "user_uploads"  # USER personal uploads

# Ensure directories exist
for directory in [CORE_MEMORY_DIR, UPLOADS_DIR, USER_UPLOADS_DIR, "logs"]:
    os.makedirs(directory, exist_ok=True)

# ADMIN KNOWLEDGE BASE - Global therapeutic resources
def load_knowledge_base():
    """Load ADMIN knowledge base - global therapeutic resources"""
    try:
        if os.path.exists(KNOWLEDGE_BASE_FILE):
            with open(KNOWLEDGE_BASE_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception as e:
        print(f"Error loading knowledge base: {e}")
    return {"documents": [], "last_updated": None, "total_documents": 0}

def save_knowledge_base(knowledge_base):
    """Save ADMIN knowledge base"""
    try:
        knowledge_base["last_updated"] = datetime.now().isoformat()
        with open(KNOWLEDGE_BASE_FILE, "w", encoding="utf-8") as f:
            json.dump(knowledge_base, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"Error saving knowledge base: {e}")

knowledge_base = load_knowledge_base()

def is_admin_user():
    """Check if current user is authenticated as admin"""
    return session.get("is_admin", False)

def extract_text_from_pdf(file_path):
    """Extract text from PDF using PyMuPDF"""
    try:
        print(f"Extracting text from PDF: {file_path}")
        doc = fitz.open(file_path)
        text = ""
        
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            page_text = page.get_text()
            text += f"\n--- Page {page_num + 1} ---\n{page_text}"
        
        doc.close()
        
        if text.strip():
            print(f"Successfully extracted {len(text)} characters from {os.path.basename(file_path)}")
            return text
        else:
            return f"No text could be extracted from {os.path.basename(file_path)}"
            
    except Exception as e:
        error_msg = f"Error extracting text from PDF {os.path.basename(file_path)}: {str(e)}"
        print(error_msg)
        return error_msg

def add_document_to_knowledge_base(file_path, filename, is_core=True):
    """Add document to ADMIN knowledge base (global therapeutic resources)"""
    try:
        text_content = extract_text_from_pdf(file_path)
        
        doc_info = {
            "filename": filename,
            "content": text_content,
            "added_date": datetime.now().isoformat(),
            "file_hash": hashlib.md5(open(file_path, 'rb').read()).hexdigest(),
            "is_core": is_core,
            "character_count": len(text_content),
            "type": "admin_therapeutic_resource"
        }
        
        # Always add to global knowledge base (admin only can call this)
        knowledge_base["documents"].append(doc_info)
        knowledge_base["total_documents"] = len(knowledge_base["documents"])
        save_knowledge_base(knowledge_base)
        print(f"Added {filename} to ADMIN knowledge base ({len(text_content)} characters)")
        
        return doc_info
    except Exception as e:
        print(f"Error adding document to knowledge base: {e}")
        return None

def add_personal_document_to_session(file_path, filename, session_id):
    """Add document to USER's personal session (not global knowledge base)"""
    try:
        text_content = extract_text_from_pdf(file_path)
        
        doc_info = {
            "filename": filename,
            "content": text_content,
            "added_date": datetime.now().isoformat(),
            "file_hash": hashlib.md5(open(file_path, 'rb').read()).hexdigest(),
            "character_count": len(text_content),
            "type": "user_personal_document",
            "session_id": session_id
        }
        
        user_session = get_user_session(session_id)
        user_session["personal_documents"].append(doc_info)
        print(f"Added {filename} to user session {session_id} ({len(text_content)} characters)")
        
        return doc_info
    except Exception as e:
        print(f"Error adding personal document: {e}")
        return None

def get_session_id():
    """Get or create session ID for user"""
    if 'session_id' not in session:
        session['session_id'] = hashlib.md5(str(datetime.now()).encode()).hexdigest()[:16]
    return session['session_id']

def get_user_session(session_id):
    """Get user session data with personal documents"""
    if session_id not in user_sessions:
        user_sessions[session_id] = {
            "chat_history": [],
            "personal_documents": [],  # USER's personal uploads (therapy notes, etc.)
            "created": datetime.now().isoformat()
        }
    return user_sessions[session_id]

# Direct Claude API call
def call_claude_direct(system_prompt, user_message):
    try:
        print("Calling Claude API directly")
        headers = {
            "Content-Type": "application/json",
            "x-api-key": claude_api_key,
            "anthropic-version": "2023-06-01"
        }
        
        data = {
            "model": "claude-3-haiku-20240307",
            "max_tokens": 1024,
            "system": system_prompt,
            "messages": [
                {"role": "user", "content": user_message}
            ]
        }
        
        response = requests.post(
            "https://api.anthropic.com/v1/messages",
            headers=headers,
            json=data,
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            return result["content"][0]["text"]
        else:
            print(f"Claude API error: {response.status_code} - {response.text}")
            return f"Error calling Claude API: {response.status_code}"
            
    except Exception as e:
        print(f"Error in direct Claude call: {e}")
        return f"Error: {str(e)}"

# Direct OpenAI API call
def call_openai_direct(system_prompt, user_message):
    try:
        print("Calling OpenAI API directly")
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {openai_api_key}"
        }
        
        data = {
            "model": "gpt-4",
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message}
            ],
            "max_tokens": 1024
        }
        
        response = requests.post(
            "https://api.openai.com/v1/chat/completions",
            headers=headers,
            json=data,
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            return result["choices"][0]["message"]["content"]
        else:
            print(f"OpenAI API error: {response.status_code} - {response.text}")
            return f"Error calling OpenAI API: {response.status_code}"
            
    except Exception as e:
        print(f"Error in direct OpenAI call: {e}")
        return f"Error: {str(e)}"

def build_context_from_knowledge_base(session_id):
    """Build context from ADMIN knowledge base + USER's personal documents"""
    context = ""
    
    # 1. ADMIN KNOWLEDGE BASE - Global therapeutic resources (for all users)
    if knowledge_base["documents"]:
        context += "\n=== THERAPEUTIC KNOWLEDGE BASE (Professional Resources) ===\n"
        for doc in knowledge_base["documents"][-5:]:  # Last 5 admin documents
            context += f"From professional resource '{doc['filename']}':\n{doc['content'][:1500]}...\n\n"
    
    # 2. USER'S PERSONAL DOCUMENTS - Their therapy notes, personal files (session-specific)
    user_session = get_user_session(session_id)
    if user_session["personal_documents"]:
        context += "\n=== YOUR PERSONAL DOCUMENTS ===\n"
        for doc in user_session["personal_documents"]:
            context += f"From your document '{doc['filename']}':\n{doc['content'][:1000]}...\n\n"
    
    return context[:8000]  # Generous limit for both types of context

def call_model(model, system, prompt, session_id):
    try:
        # Add both admin knowledge + user personal documents
        knowledge_context = build_context_from_knowledge_base(session_id)
        if knowledge_context:
            system += f"\n\nCONTEXT AVAILABLE TO YOU:\n{knowledge_context}"
        
        if "gpt" in model:
            print(f"Using OpenAI via direct API: {model}")
            if not openai_api_key:
                return "Error: OpenAI API key not configured"
            return call_openai_direct(system, prompt)
        else:
            print(f"Using Claude via direct API: {model}")
            if not claude_api_key:
                return "Error: Claude API key not configured"
            return call_claude_direct(system, prompt)
    except Exception as e:
        print(f"Error calling model: {e}")
        return f"Error: {str(e)}"

@app.route("/", methods=["GET"])
def index():
    session_id = get_session_id()
    is_admin = is_admin_user()
    return render_template("index.html", is_admin=is_admin)

@app.route("/admin", methods=["GET", "POST"])
def admin():
    if request.method == "POST":
        password = request.form.get("password")
        if password == admin_password:
            session["is_admin"] = True
            return redirect("/admin")
        else:
            return render_template("admin_login.html", error="Invalid password")
    
    if not session.get("is_admin"):
        return render_template("admin_login.html")
    
    return render_template("admin_dashboard.html", 
                         knowledge_base=knowledge_base,
                         total_docs=len(knowledge_base["documents"]))

@app.route("/chat", methods=["POST"])
def chat():
    try:
        session_id = get_session_id()
        user_session = get_user_session(session_id)
        
        data = request.get_json()
        user_input = data.get("user_input", "")
        agent = data.get("agent", "")

        print(f"Chat request - User: {user_input}, Agent: {agent}, Session: {session_id}")

        user_session["chat_history"].append({"role": "user", "content": user_input})

        if agent == "case_assistant":
            system_prompt = "You assist with social work case analysis. Focus on context, safeguarding, and systemic risk. Use the professional knowledge base AND the user's personal documents to inform your responses."
            model = config["claude_model"]
        elif agent == "research_critic":
            system_prompt = "You are a critical evaluator of research. Be sharp, analytical, and cite relevant frameworks. Reference both professional resources and the user's personal materials."
            model = config["openai_model"]
        elif agent == "therapy_planner":
            system_prompt = "You are a strategic therapist. Plan sessions and structure interventions using systemic and psychoanalytic models. Draw on professional knowledge and the user's personal therapy context."
            model = config["openai_model"]
        else:
            system_prompt = config["claude_system_prompt"] + " Use both the professional therapeutic knowledge base and the user's personal documents to provide contextually grounded responses."
            model = config["claude_model"]

        response_text = call_model(model, system_prompt, user_input, session_id)
        user_session["chat_history"].append({"role": "assistant", "content": response_text})

        return jsonify({"response": response_text})
    except Exception as e:
        print(f"Error in chat endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route("/upload", methods=["POST"])
def upload():
    try:
        session_id = get_session_id()
        
        if "pdf" not in request.files:
            return jsonify({"message": "No file selected", "success": False})
        
        file = request.files["pdf"]
        if not file or not file.filename:
            return jsonify({"message": "No file selected", "success": False})
            
        if not file.filename.lower().endswith(".pdf"):
            return jsonify({"message": "Please select a PDF file", "success": False})
        
        upload_type = request.form.get("upload_type", "personal")  # "admin" or "personal"
        
        if upload_type == "admin":
            # ADMIN UPLOAD - Global knowledge base
            if not is_admin_user():
                return jsonify({
                    "message": "Access denied. Only administrators can upload to the global knowledge base.", 
                    "success": False
                }), 403
            
            file_path = os.path.join(UPLOADS_DIR, file.filename)
            file.save(file_path)
            doc_info = add_document_to_knowledge_base(file_path, file.filename, is_core=True)
            
            if doc_info:
                return jsonify({
                    "message": f"Added '{file.filename}' to global therapeutic knowledge base ({doc_info['character_count']} characters)", 
                    "success": True,
                    "type": "admin"
                })
        else:
            # USER UPLOAD - Personal session documents
            file_path = os.path.join(USER_UPLOADS_DIR, f"{session_id}_{file.filename}")
            file.save(file_path)
            doc_info = add_personal_document_to_session(file_path, file.filename, session_id)
            
            if doc_info:
                return jsonify({
                    "message": f"Added '{file.filename}' to your personal session ({doc_info['character_count']} characters)", 
                    "success": True,
                    "type": "personal"
                })
        
        return jsonify({"message": "Upload processing failed", "success": False})
        
    except Exception as e:
        print(f"Error in upload endpoint: {e}")
        return jsonify({"error": str(e), "success": False})

@app.route("/clear", methods=["POST"])
def clear():
    try:
        session_id = get_session_id()
        user_session = get_user_session(session_id)
        user_session["chat_history"] = []
        # Note: We DON'T clear personal_documents - user may want to keep their files
        return jsonify({"message": "Chat history cleared (personal documents retained)"})
    except Exception as e:
        print(f"Error in clear endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route("/clear-documents", methods=["POST"])
def clear_documents():
    """Clear user's personal documents (separate from chat)"""
    try:
        session_id = get_session_id()
        user_session = get_user_session(session_id)
        cleared_count = len(user_session["personal_documents"])
        user_session["personal_documents"] = []
        return jsonify({"message": f"Cleared {cleared_count} personal documents"})
    except Exception as e:
        print(f"Error in clear documents endpoint: {e}")
        return jsonify({"error": str(e)}), 500

@app.route("/log", methods=["GET"])
def get_log():
    session_id = get_session_id()
    user_session = get_user_session(session_id)
    return jsonify(user_session["chat_history"])

@app.route("/personal-documents", methods=["GET"])
def get_personal_documents():
    """Get user's personal documents"""
    session_id = get_session_id()
    user_session = get_user_session(session_id)
    return jsonify({
        "personal_documents": [
            {
                "filename": doc["filename"],
                "added_date": doc["added_date"],
                "character_count": doc["character_count"]
            }
            for doc in user_session["personal_documents"]
        ]
    })

@app.route("/knowledge-base", methods=["GET"])
def get_knowledge_base():
    """API endpoint to view admin knowledge base status"""
    return jsonify({
        "total_documents": len(knowledge_base["documents"]),
        "last_updated": knowledge_base.get("last_updated"),
        "documents": [{"filename": doc["filename"], "added_date": doc["added_date"], "character_count": doc.get("character_count", 0)} 
                     for doc in knowledge_base["documents"]]
    })

@app.route("/health")
def health():
    openai_works = False
    claude_works = False
    
    if openai_api_key:
        try:
            test_response = call_openai_direct("You are a test assistant.", "Hello")
            openai_works = not test_response.startswith("Error")
        except:
            openai_works = False
    
    if claude_api_key:
        try:
            test_response = call_claude_direct("You are a test assistant.", "Hello")
            claude_works = not test_response.startswith("Error")
        except:
            claude_works = False
    
    return jsonify({
        "status": "healthy",
        "openai_configured": openai_api_key is not None,
        "openai_client_works": openai_works,
        "claude_configured": claude_api_key is not None,
        "claude_client_works": claude_works,
        "knowledge_base_documents": len(knowledge_base["documents"]),
        "pdf_support": True,
        "two_tier_storage": True,
        "note": "Two-tier system: Admin knowledge base + User personal documents"
    })

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
else:
    application = app
